"""message_plan.py â€” pure Python, no LLM.

Generates an ordered list of message roles for a dialogue, e.g.:
  ["client", "agent", "client", "client", "agent", "client", "agent"]

Rules:
- first message is always "client"
- last message follows OUTCOME_LAST_ROLE
- at least one "agent" in the list
- middle is generated by a randomly selected pattern
"""

import random

# Who speaks last, per outcome
OUTCOME_LAST_ROLE: dict[str, str] = {
    "unresolved_ragequit": "client",
    "resolved_quick": "agent",
    "resolved_neutral": "agent",
    "unresolved_passive": "client",
    "conflict": "agent",
    "info_only": "agent",
}


def generate_plan(
    n_messages: int,
    outcome: str,
    rng: random.Random,
) -> list[str]:
    """Return ordered list of roles with exactly n_messages entries."""
    if n_messages < 2:
        n_messages = 2

    last = OUTCOME_LAST_ROLE.get(outcome, "agent")
    middle_count = n_messages - 2

    if middle_count <= 0:
        plan = ["client", last]
    else:
        pattern = rng.choices(
            ["balanced", "client_spam", "agent_consolidates"],
            weights=[60, 20, 20],
        )[0]
        middle = _build_middle(middle_count, pattern, rng)
        plan = ["client"] + middle + [last]

        # guard: no more than 2 identical roles in a row
        plan = _limit_consecutive(plan, max_run=2)

    # safety: ensure at least 1 agent
    if "agent" not in plan:
        plan.insert(1, "agent")

    return plan


def _limit_consecutive(plan: list[str], max_run: int = 2) -> list[str]:
    """Ensure no role appears more than max_run times in a row.
    Inserts the opposite role when exceeded."""
    result: list[str] = []
    run = 0
    prev = None
    for role in plan:
        if role == prev:
            run += 1
        else:
            run = 1
            prev = role
        if run <= max_run:
            result.append(role)
        else:
            opposite = "agent" if role == "client" else "client"
            result.append(opposite)
            result.append(role)
            run = 1
    return result


def _build_middle(n: int, pattern: str, rng: random.Random) -> list[str]:
    if n <= 0:
        return []

    if pattern == "balanced":
        roles, toggle = [], "agent"
        for _ in range(n):
            roles.append(toggle)
            toggle = "client" if toggle == "agent" else "agent"
        return roles

    elif pattern == "client_spam":
        roles = []
        while len(roles) < n:
            spam = rng.randint(1, min(2, n - len(roles)))
            roles += ["client"] * spam
            if len(roles) < n:
                roles.append("agent")
        return roles[:n]

    elif pattern == "agent_consolidates":
        roles = []
        while len(roles) < n:
            burst = rng.randint(1, min(2, n - len(roles)))
            roles += ["client"] * burst
            if len(roles) < n:
                roles.append("agent")
        return roles[:n]

    return (["agent", "client"] * (n // 2 + 1))[:n]


def plan_to_template(
    plan: list[str],
    client_name: str,
    agent_name: str,
) -> str:
    """Convert role plan to numbered LLM prompt template.

    Example output:
        1. CLIENT (Jamie): [write message here]
        2. AGENT (Emily):  [write message here]
        3. CLIENT (Jamie): [write message here]
    """
    lines = []
    for i, role in enumerate(plan):
        name = client_name if role == "client" else agent_name
        lines.append(f"{i + 1}. {role.upper()} ({name}): [write message here]")
    return "\n".join(lines)
